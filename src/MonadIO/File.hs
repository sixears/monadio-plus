{-# LANGUAGE FlexibleContexts  #-}
{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
{-# LANGUAGE RankNTypes        #-}
{-# LANGUAGE TypeApplications  #-}
{-# LANGUAGE UnicodeSyntax     #-}
{-# LANGUAGE ViewPatterns      #-}

module MonadIO.File
  ( System.IO.IOMode(..)
  , hClose

  , devnull

  , access, stat, writable

  , fileWritable, isWritableFile, isWritableDir

  , openFile', openFileBinary', openFileUTF8'
  , openFile, openFileBinary, openFileUTF8

  , openFileReadBinary', openFileReadWriteBinary', openFileReadWriteExBinary'
  , openFileReadWriteNoTruncBinary'
  , openFileWriteExBinary', openFileWriteBinary', openFileWriteNoTruncBinary'
  , openFileAppendBinary'
  
  , openFileReadUTF8', openFileReadWriteUTF8', openFileReadWriteExUTF8'
  , openFileReadWriteNoTruncUTF8'
  , openFileWriteExUTF8', openFileWriteUTF8', openFileWriteNoTruncUTF8'
  , openFileAppendUTF8'
  
  , openFileReadBinary, openFileReadWriteBinary, openFileReadWriteExBinary
  , openFileReadWriteNoTruncBinary
  , openFileWriteExBinary, openFileWriteBinary, openFileWriteNoTruncBinary
  , openFileAppendBinary
  
  , openFileReadUTF8, openFileReadWriteUTF8, openFileReadWriteExUTF8
  , openFileReadWriteNoTruncUTF8
  , openFileWriteExUTF8, openFileWriteUTF8, openFileWriteNoTruncUTF8
  , openFileAppendUTF8
  
  , withFile, withFileME, withFileUTF8, withFileBinary

  , withReadFileBinary, withReadWriteFileBinary, withReadWriteExFileBinary
  , withReadWriteNoTruncFileBinary
  , withWriteFileBinary, withWriteExFileBinary, withWriteNoTruncFileBinary
  , withAppendFileBinary

  , withReadFileUTF8, withReadWriteFileUTF8, withReadWriteExFileUTF8
  , withReadWriteNoTruncFileUTF8
  , withWriteFileUTF8, withWriteExFileUTF8, withWriteNoTruncFileUTF8
  , withAppendFileUTF8

  , readFileBinary, writeFileBinary, writeExFileBinary, writeNoTruncFileBinary
  , appendFileBinary

  , readFileUTF8, writeFileUTF8, writeNoTruncFileUTF8, writeExFileUTF8
  , appendFileUTF8

  , readFileUTF8Lenient
  
  , fileFoldLinesUTF8, fileFoldLinesH

  , readFlags, readWriteFlags, readWriteExFlags, readWriteNoTruncFlags
  , writeFlags, writeExFlags, writeNoTruncFlags, appendFlags
  )
where

-- base --------------------------------

import qualified  System.IO

import Control.Exception       ( bracket )
import Control.Monad           ( join, return )
import Control.Monad.IO.Class  ( MonadIO, liftIO )
import Data.Bool               ( Bool( False, True ), bool )
import Data.Either             ( Either)
import Data.Eq                 ( Eq )
import Data.Function           ( ($), flip )
import Data.Maybe              ( Maybe( Just, Nothing ), fromMaybe )
import Data.String             ( String )
import System.Exit             ( ExitCode )
import System.IO               ( FilePath, Handle, IO, NewlineMode, TextEncoding
                               , IOMode( AppendMode, ReadMode, ReadWriteMode
                                       , WriteMode )
                               , char8, hIsEOF, hSetEncoding, hSetNewlineMode
                               , nativeNewlineMode, noNewlineTranslation, utf8
                               )
import System.Posix.Types      ( FileMode )
import Text.Show               ( Show )

-- base-unicode-symbols ----------------

import Data.Function.Unicode  ( (‚àò) )
import Data.Monoid.Unicode    ( (‚äï) )

-- bytestring --------------------------

import qualified Data.ByteString  as  BS

import Data.ByteString  ( ByteString )

-- data-textual ------------------------

import Data.Textual  ( toString )

-- fpath -------------------------------

import FPath.AbsDir       ( absdir )
import FPath.AbsFile      ( absfile )
import FPath.AsFilePath   ( AsFilePath( filepath ) )
import FPath.AsFilePath'  ( exterminate )
import FPath.DirLike      ( IsDir )
import FPath.File         ( FileAs( _File_ ) )
import FPath.Parent       ( parent )

-- lens --------------------------------

import Control.Lens.Review  ( review )

-- monadio-error -----------------------

import MonadError           ( —• )
import MonadError.IO        ( asIOError, asIOErrorY )
import MonadError.IO.Error  ( AsIOError, IOError, squashInappropriateTypeT )

-- more-unicode ------------------------

import Data.MoreUnicode.Bool     ( ùîπ )
import Data.MoreUnicode.Functor  ( (‚ä≥), (‚ä≥‚ä≥‚ä≥), (‚©∫) )
import Data.MoreUnicode.Lens     ( (‚ä£), (‚´•) )
import Data.MoreUnicode.Maybe    ( ùïÑ )
import Data.MoreUnicode.Monad    ( (‚â´) )
import Data.MoreUnicode.Natural  ( ‚Ñï )
import Data.MoreUnicode.Text     ( ùïã )

-- mtl ---------------------------------

import Control.Monad.Except  ( ExceptT, MonadError )

-- tasty -------------------------------

import Test.Tasty  ( TestTree, testGroup )

-- tasty-hunit -------------------------

import Test.Tasty.HUnit  ( Assertion, (@=?), testCase )

-- tasty-plus --------------------------

import TastyPlus  ( assertIsLeft, assertRight, runTestsP, runTestsReplay
                  , runTestTree )

-- text --------------------------------

import qualified  Data.Text.IO  as  TextIO

import Data.Text                 ( drop, length )
import Data.Text.Encoding        ( decodeUtf8With )
import Data.Text.Encoding.Error  ( lenientDecode )

-- tfmt --------------------------------

import Text.Fmt  ( fmt )

-- unix --------------------------------

import qualified  System.Posix.Files  as  Files
import System.Posix.Files  ( FileStatus, fileExist, getFileStatus, isDirectory
                           , removeLink, setFileMode )
import System.Posix.IO     ( OpenFileFlags( OpenFileFlags, append, exclusive
                                          , noctty, nonBlock, trunc ),
                             OpenMode( ReadOnly, ReadWrite, WriteOnly )
                           , fdToHandle, noctty, nonBlock, openFd
                           )

--------------------------------------------------------------------------------

data FExists = FExists | NoFExists
  deriving (Eq,Show)

{- | Does file exist.  Note that "does /etc/passwd/ exist?", where /etc/passwd
     exists but is a file, will return `NoFExists`; but "does /etc exist?" where
     /etc exists but is a directory will return `FExists`.  See also `fexists'`.
 -}
fexists ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, AsFilePath œÑ) ‚áí œÑ ‚Üí Œº FExists
-- fileExist throws an InappropriateType IOException if you ask about a file
-- in a non-existent directory.  I think that sucks, and should be a simple
-- False (NoFExists)
fexists f = fromMaybe NoFExists ‚©∫ squashInappropriateTypeT ‚àò asIOError $
              bool NoFExists FExists ‚ä≥ fileExist (f ‚´• filepath)

----------

fexistsTests ‚à∑ TestTree
fexistsTests =
  let testFExists expect input =
        testCase (toString input) $
          (—• @IOError (fexists input)) ‚â´ assertRight (expect @=?)
   in testGroup "fexists"
                [ testFExists FExists   [absdir|/etc/|]
                , testFExists NoFExists [absdir|/nonsuch/|]
                , testFExists NoFExists [absdir|/etc/nonsuch/|]
                , testFExists FExists   [absfile|/etc/passwd|]
                , testFExists NoFExists [absdir|/etc/passwd/|]
                , testFExists NoFExists [absfile|/etc/passwd/nonsuch|]
                , testFExists NoFExists [absdir|/etc/passwd/nonsuch/|]
                ]

--------------------

{- | Does file exist.  Note that "does /etc/passwd/ exist?", where /etc/passwd
     exists but is a file, will return `FExists`.  See also `fexists`.  This is
     more symmetric, since "does /etc exist?" where /etc exists but is a
     directory will return `FExists`; but at a cost of being arguably less
     accurate.
 -}
fexists' ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, AsFilePath œÑ)‚áí œÑ ‚Üí Œº FExists
-- fileExist throws an InappropriateType IOException if you ask about a file
-- in a directory that is in reality a file.  I think that sucks, and should be
-- a simple False (NoFExists)
fexists' f = fromMaybe NoFExists ‚©∫ squashInappropriateTypeT ‚àò asIOError $
               bool NoFExists FExists ‚ä≥ fileExist (exterminate $ f ‚´• filepath)

----------

fexists'Tests ‚à∑ TestTree
fexists'Tests =
  let testFExists' expect input =
        testCase (toString input) $
          (—• @IOError (fexists' input)) ‚â´ assertRight (expect @=?)
   in testGroup "fexists'"
                [ testFExists' FExists   [absdir|/etc/|]
                , testFExists' NoFExists [absdir|/nonsuch/|]
                , testFExists' NoFExists [absdir|/etc/nonsuch/|]
                , testFExists' FExists   [absfile|/etc/passwd|]
                , testFExists' FExists   [absdir|/etc/passwd/|]
                , testFExists' NoFExists [absfile|/etc/passwd/nonsuch|]
                , testFExists' NoFExists [absdir|/etc/passwd/nonsuch/|]
                ]

----------------------------------------

-- | file stat; returns Nothing if file does not exist
stat ‚à∑ ‚àÄ Œµ œÅ Œº . (MonadIO Œº, AsFilePath œÅ, AsIOError Œµ, MonadError Œµ Œº) ‚áí
       œÅ ‚Üí Œº (ùïÑ FileStatus)
stat f = do
  -- The fexists' introduces a race-condition - bah - but without it, the
  -- stat may fail with an `InappropriateType` IOException when trying to stat
  -- a file in a "directory" that is in reality a file.  I think that sucks, and
  -- want to try that like any other non-existent file.
  fexists' f ‚â´ \ case
    NoFExists ‚Üí return Nothing
    FExists   ‚Üí asIOErrorY ‚àò getFileStatus ‚àò exterminate $ (f ‚´• filepath)

----------

statTests ‚à∑ TestTree
statTests =
  let testStat expect input f =
        testCase (toString input) $
          f (—• @IOError (stat input)) ‚â´ assertRight (expect @=?)
   in testGroup "stat"
                [ testStat (Just True)  [absdir|/etc/|]        (isDirectory ‚ä≥‚ä≥‚ä≥)
                , testStat (Just False) [absfile|/etc/passwd|] (isDirectory ‚ä≥‚ä≥‚ä≥)
                , testStat (Just False) [absdir|/etc/passwd/|] (isDirectory ‚ä≥‚ä≥‚ä≥)
                , testStat Nothing      [absfile|/nonsuch|]    (isDirectory ‚ä≥‚ä≥‚ä≥)
                , testStat Nothing      [absfile|/etc/passwd/nonsuch|]
                                                               (isDirectory ‚ä≥‚ä≥‚ä≥)
                , testStat Nothing      [absdir|/nonsuch/|]    (isDirectory ‚ä≥‚ä≥‚ä≥)
                ]

----------------------------------------

{- | OpenFileFlags suitable for reading. -}
readFlags ‚à∑ OpenFileFlags
readFlags = OpenFileFlags { append = False, exclusive = False, noctty = False,
                             nonBlock = False, trunc = False }
--------------------

{- | OpenFileFlags suitable for read-write opens /with pre-truncation/
     (analogous to writeFlags) . -}
readWriteFlags ‚à∑ OpenFileFlags
readWriteFlags = OpenFileFlags { append = False, exclusive = False
                               , noctty = False, nonBlock = False
                               , trunc = True
                               }

--------------------

{- | OpenFileFlags suitable for read-write opens /with pre-truncation/
     (analogous to writeFlags) . -}
readWriteNoTruncFlags ‚à∑ OpenFileFlags
readWriteNoTruncFlags = OpenFileFlags { append = False, exclusive = False
                                      , noctty = False, nonBlock = False
                                      , trunc = False
                                      }

--------------------

{- | OpenFileFlags suitable for read-write opens, with exclusive (file must
     not pre-exist (man file(2):O_EXCL). -}
readWriteExFlags ‚à∑ OpenFileFlags
readWriteExFlags = OpenFileFlags { append = False, exclusive = True
                                 , noctty = False, nonBlock = False
                                 , trunc = False
                                 }

--------------------

{- | OpenFileFlags suitable for writing /with pre-truncation/; this is just the
      `trunc` (man file(2):O_TRUNC) flag. -}
writeFlags ‚à∑ OpenFileFlags
writeFlags = OpenFileFlags { append = False, exclusive = False, noctty = False
                           , nonBlock = False, trunc = True }

--------------------

{- | OpenFileFlags suitable for writing /without pre-truncating/. -}
writeNoTruncFlags ‚à∑ OpenFileFlags
writeNoTruncFlags = OpenFileFlags { append = False, exclusive = False
                                  , noctty = False, nonBlock = False
                                  , trunc = False }

--------------------

{- | OpenFileFlags suitable for writing a new file; this is just the `exclusive`
     (man file(2):O_EXCL) flag.
     This seems redundant in practice, but I've added it here as a belt'n'braces
     thing.
-}
writeExFlags ‚à∑ OpenFileFlags
writeExFlags = OpenFileFlags { append = False, exclusive = True, noctty = False,
                               nonBlock = False, trunc = False }

--------------------

{- | OpenFileFlags suitable for appending; this is just the `append`
     (man file(2):O_APPEND) flag. -}
appendFlags ‚à∑ OpenFileFlags
appendFlags = OpenFileFlags { append = True, exclusive = False, noctty = False,
                              nonBlock = False, trunc = False }

----------------------------------------

openFile' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí
            TextEncoding ‚Üí NewlineMode ‚Üí IOMode ‚Üí OpenFileFlags ‚Üí (ùïÑ FileMode)
          ‚Üí Œ≥ ‚Üí Œº Handle
openFile' enc nlm mode flags perms (review _File_ ‚Üí fn) = liftIO $ do
  let openMode ReadMode      = ReadOnly
      openMode WriteMode     = WriteOnly
      openMode ReadWriteMode = ReadWrite
      openMode AppendMode    = WriteOnly
      flags'   = case mode of
                   AppendMode ‚Üí flags { append = True }
                   _          ‚Üí flags
  h ‚Üê openFd (fn ‚´• filepath) (openMode mode) perms flags' ‚â´ fdToHandle
  hSetEncoding h enc
  hSetNewlineMode h nlm
  return h

--------------------

openFileUTF8' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí
                IOMode ‚Üí OpenFileFlags ‚Üí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileUTF8' = openFile' utf8 nativeNewlineMode

--------------------

openFileBinary' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí
                  IOMode ‚Üí OpenFileFlags ‚Üí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileBinary' = openFile' char8 noNewlineTranslation

----------------------------------------

openFile ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
           TextEncoding ‚Üí NewlineMode ‚Üí IOMode ‚Üí OpenFileFlags ‚Üí (ùïÑ FileMode)
         ‚Üí Œ≥ ‚Üí Œº Handle
openFile enc nlm mode flags perms fn =
   asIOError $ openFile' enc nlm mode flags perms fn

--------------------

openFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                  IOMode ‚Üí OpenFileFlags ‚Üí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileUTF8 mode flags perms = asIOError ‚àò openFileUTF8' mode flags perms

--------------------

openFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                  IOMode ‚Üí OpenFileFlags ‚Üí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileBinary mode flags perms =
  asIOError ‚àò openFileBinary' mode flags perms

----------------------------------------

openFileReadBinary' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí Œ≥ ‚Üí Œº Handle
openFileReadBinary' = liftIO ‚àò openFileBinary' ReadMode readFlags Nothing

openFileReadWriteBinary' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteBinary' perms =
  openFileBinary' ReadWriteMode readWriteFlags perms

openFileReadWriteNoTruncBinary' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí
                                  (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteNoTruncBinary' perms =
  openFileBinary' ReadWriteMode readWriteNoTruncFlags perms

openFileReadWriteExBinary' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí
                             (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteExBinary' perms =
  openFileBinary' ReadWriteMode readWriteExFlags perms

openFileWriteNoTruncBinary' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí
                              (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteNoTruncBinary' perms =
  openFileBinary' WriteMode writeNoTruncFlags perms

openFileWriteExBinary' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí FileMode ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteExBinary' perms =
  openFileBinary' WriteMode writeExFlags (Just perms)

openFileWriteBinary' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteBinary' perms =
  openFileBinary' WriteMode writeFlags perms

openFileAppendBinary' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileAppendBinary' perms = openFileBinary' AppendMode appendFlags perms

----------------------------------------

openFileReadUTF8' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí Œ≥ ‚Üí Œº Handle
openFileReadUTF8' = liftIO ‚àò openFileUTF8' ReadMode readFlags Nothing

openFileReadWriteUTF8' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteUTF8' perms = openFileUTF8' ReadWriteMode readWriteFlags perms

openFileReadWriteNoTruncUTF8' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí
                                (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteNoTruncUTF8' perms =
  openFileUTF8' ReadWriteMode readWriteNoTruncFlags perms

openFileReadWriteExUTF8' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteExUTF8' perms =
  openFileUTF8' ReadWriteMode readWriteExFlags perms

openFileWriteUTF8' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteUTF8' perms = openFileUTF8' WriteMode writeFlags perms

openFileWriteNoTruncUTF8' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteNoTruncUTF8' perms =
  openFileUTF8' WriteMode writeNoTruncFlags perms

openFileWriteExUTF8' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí FileMode ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteExUTF8' perms = openFileUTF8' WriteMode writeExFlags (Just perms)

openFileAppendUTF8' ‚à∑ (MonadIO Œº, FileAs Œ≥) ‚áí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileAppendUTF8' perms = openFileUTF8' AppendMode appendFlags perms

----------------------------------------

openFileReadBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                       Œ≥ ‚Üí Œº Handle
openFileReadBinary = asIOError ‚àò openFileReadBinary'

openFileReadWriteBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                          (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteBinary perms = asIOError ‚àò openFileReadWriteBinary' perms

openFileReadWriteNoTruncBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº,
                                  FileAs Œ≥) ‚áí
                                 (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteNoTruncBinary perms =
  asIOError ‚àò openFileReadWriteNoTruncBinary' perms

openFileReadWriteExBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                          (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteExBinary perms = asIOError ‚àò openFileReadWriteExBinary' perms

openFileWriteBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                      (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteBinary perms = asIOError ‚àò openFileWriteBinary' perms

openFileWriteNoTruncBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                      (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteNoTruncBinary perms = asIOError ‚àò openFileWriteNoTruncBinary' perms

openFileWriteExBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                        FileMode ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteExBinary perms = asIOError ‚àò openFileWriteExBinary' perms

openFileAppendBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                       (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileAppendBinary perms = asIOError ‚àò openFileAppendBinary' perms

----------------------------------------

openFileReadUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                   Œ≥ ‚Üí Œº Handle
openFileReadUTF8 = asIOError ‚àò openFileReadUTF8'

openFileReadWriteUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                        (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteUTF8 perms = asIOError ‚àò openFileReadWriteUTF8' perms

openFileReadWriteNoTruncUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº,
                                FileAs Œ≥) ‚áí
                               (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteNoTruncUTF8 perms =
  asIOError ‚àò openFileReadWriteNoTruncUTF8' perms

openFileReadWriteExUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                          (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileReadWriteExUTF8 perms = asIOError ‚àò openFileReadWriteExUTF8' perms

openFileWriteUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                    (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteUTF8 perms = asIOError ‚àò openFileWriteUTF8' perms

openFileWriteNoTruncUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                           (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteNoTruncUTF8 perms = asIOError ‚àò openFileWriteNoTruncUTF8' perms

openFileWriteExUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                      FileMode ‚Üí Œ≥ ‚Üí Œº Handle
openFileWriteExUTF8 perms = asIOError ‚àò openFileWriteExUTF8' perms

openFileAppendUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                     (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí Œº Handle
openFileAppendUTF8 perms = asIOError ‚àò openFileAppendUTF8' perms

----------------------------------------

withFile ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
           TextEncoding ‚Üí NewlineMode ‚Üí IOMode ‚Üí OpenFileFlags ‚Üí (ùïÑ FileMode)
         ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withFile enc nlm mode flags perms (review _File_ ‚Üí fn) io = asIOError $
   bracket (openFile' enc nlm mode flags perms fn) System.IO.hClose io

--------------------

withFileME ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
             TextEncoding ‚Üí NewlineMode ‚Üí IOMode ‚Üí OpenFileFlags
           ‚Üí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí ExceptT Œµ IO œâ) ‚Üí Œº œâ
withFileME enc nlm mode flags perms fn io =
  join $ withFile enc nlm mode flags perms fn (—• ‚àò io)

----------------------------------------

withFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                 IOMode ‚Üí OpenFileFlags ‚Üí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ)
               ‚Üí Œº œâ
withFileUTF8 = withFile utf8 nativeNewlineMode

--------------------

withFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                   IOMode ‚Üí OpenFileFlags ‚Üí (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ)
                 ‚Üí Œº œâ
withFileBinary = withFile char8 noNewlineTranslation

----------------------------------------

withReadFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                   Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withReadFileBinary = withFileBinary ReadMode readFlags Nothing

withReadWriteFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                          (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withReadWriteFileBinary perms =
  withFileBinary ReadWriteMode readWriteFlags perms

withReadWriteNoTruncFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ,
                                  MonadError Œµ Œº) ‚áí
                                 (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withReadWriteNoTruncFileBinary perms =
  withFileBinary ReadWriteMode readWriteNoTruncFlags perms

withReadWriteExFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                            FileMode ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withReadWriteExFileBinary perms =
  withFileBinary ReadWriteMode readWriteExFlags (Just perms)

withWriteFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                    (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withWriteFileBinary perms = withFileBinary WriteMode writeFlags perms

withWriteNoTruncFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ,
                              MonadError Œµ Œº) ‚áí
                             (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withWriteNoTruncFileBinary perms =
  withFileBinary WriteMode writeNoTruncFlags perms

withWriteExFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                        FileMode ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withWriteExFileBinary perms = withFileBinary WriteMode writeExFlags (Just perms)

withAppendFileBinary ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                       (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withAppendFileBinary perms = withFileBinary AppendMode appendFlags perms

----------------------------------------

withReadFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                   Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withReadFileUTF8 = withFileUTF8 ReadMode readFlags Nothing

withReadWriteFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                        (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withReadWriteFileUTF8 perms = withFileUTF8 ReadWriteMode readWriteFlags perms

withReadWriteNoTruncFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ,
                                  MonadError Œµ Œº) ‚áí
                                 (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withReadWriteNoTruncFileUTF8 perms =
  withFileUTF8 ReadWriteMode readWriteNoTruncFlags perms

withReadWriteExFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                          FileMode ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withReadWriteExFileUTF8 perms =
  withFileUTF8 ReadWriteMode readWriteExFlags (Just perms)

withWriteFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                    (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withWriteFileUTF8 perms = withFileUTF8 WriteMode writeFlags perms

withWriteNoTruncFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ,
                            MonadError Œµ Œº) ‚áí
                           (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withWriteNoTruncFileUTF8 perms = withFileUTF8 WriteMode writeNoTruncFlags perms

withWriteExFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                      FileMode ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withWriteExFileUTF8 perms = withFileUTF8 WriteMode writeExFlags (Just perms)

withAppendFileUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                       (ùïÑ FileMode) ‚Üí Œ≥ ‚Üí (Handle ‚Üí IO œâ) ‚Üí Œº œâ
withAppendFileUTF8 perms = withFileUTF8 AppendMode appendFlags perms

----------------------------------------

{- | Read a file in UTF8 encoding using OS-specific line-ending handling.
     Throw an exception on invalid character.
 -}
readFileUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí Œ≥ ‚Üí Œº ùïã
readFileUTF8 fn = withReadFileUTF8 fn TextIO.hGetContents

{- | Read a file as bytes. -}
readFileBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                 Œ≥ ‚Üí Œº ByteString
readFileBinary fn = withReadFileBinary fn BS.hGetContents

writeFileBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                  ùïÑ FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí Œº ()
writeFileBinary perms fn t =
  withWriteFileBinary perms fn (flip TextIO.hPutStr t)

{- | Write a file in UTF8 encoding using OS-specific line-ending handling.
     `perms`, if not Nothing, will be used to create the file if it doesn't
     exist.  If it does exist, `perms` has no impact (use `chmod` to really
     force it).  If `perms is Nothing, and the file does not exist, then an
     exception shall be thrown.
 -}
writeFileUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                ùïÑ FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí Œº ()
writeFileUTF8 perms fn t = withWriteFileUTF8 perms fn (flip TextIO.hPutStr t)

writeNoTruncFileBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                         ùïÑ FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí Œº ()
writeNoTruncFileBinary perms fn t =
  withWriteNoTruncFileBinary perms fn (flip TextIO.hPutStr t)

writeNoTruncFileUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                        ùïÑ FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí Œº ()
writeNoTruncFileUTF8 perms fn t =
  withWriteNoTruncFileUTF8 perms fn (flip TextIO.hPutStr t)

writeExFileBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                  FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí Œº ()
writeExFileBinary perms fn t =
  withWriteExFileBinary perms fn (flip TextIO.hPutStr t)

writeExFileUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                  FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí Œº ()
writeExFileUTF8 perms fn t = withWriteExFileUTF8 perms fn (flip TextIO.hPutStr t)

{- | Write a file in UTF8 encoding using OS-specific line-ending handling.
     `perms`, if not Nothing, will be used to create the file if it doesn't
     exist.  If it does exist, `perms` has no impact (use `chmod` to really
     force it).  If `perms is Nothing, and the file does not exist, then an
     exception shall be thrown.
 -}
appendFileUTF8 ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                ùïÑ FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí Œº ()
appendFileUTF8 perms fn t =
  withFileUTF8 AppendMode appendFlags perms fn (flip TextIO.hPutStr t)

appendFileBinary ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí
                ùïÑ FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí Œº ()
appendFileBinary perms fn t =
  withFileBinary AppendMode appendFlags perms fn (flip TextIO.hPutStr t)

withFileTests ‚à∑ TestTree
withFileTests =
  let f = [absfile|/tmp/monadio-file-test.txt|]
      txt = "Swap twenty bottles for an aqua-walkman"
      t2  = "Medicine Show: "
      assertIsRight ‚à∑ Either IOError () ‚Üí Assertion
      assertIsRight = assertRight (\ _ ‚Üí () @=? ())
      read ‚à∑ FileAs Œ≥ ‚áí Œ≥ ‚Üí IO (Either IOError ùïã)
      read fn = —• $ readFileUTF8 fn
      write ‚à∑ FileAs Œ≥ ‚áí ùïÑ FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí IO (Either IOError ())
      write perms fn t = —• $ writeFileUTF8 perms fn t
      writeNoTrunc ‚à∑ FileAs Œ≥ ‚áí ùïÑ FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí IO (Either IOError ())
      writeNoTrunc perms fn t = —• $ writeNoTruncFileUTF8 perms fn t
      -- `append` is imported from System.Posix.IO, so don't shadow that
      appnd ‚à∑ FileAs Œ≥ ‚áí ùïÑ FileMode ‚Üí Œ≥ ‚Üí ùïã ‚Üí IO (Either IOError ())
      appnd perms fn t = —• $ appendFileUTF8 perms fn t
      testRead fn t =
        testCase "readFileUTF8" $ read fn ‚â´ assertRight (t @=?)
      testReadFail fn =
        testCase "readFileUTF8 fail" $ read fn ‚â´ assertIsLeft
      testWrite perms fn t =
        testCase "writeFileUTF8" $ write perms fn t ‚â´ assertIsRight
      testWriteNoTrunc perms fn t =
        testCase "writeNoTruncFileUTF8" $
          writeNoTrunc perms fn t ‚â´ assertIsRight
      testWriteFail perms fn t =
        testCase "writeFileUTF8 fail" $ write perms fn t ‚â´ assertIsLeft
      testAppend perms fn t =
        testCase "appendFileUTF8" $ appnd perms fn t ‚â´ assertIsRight
      testAppendFail perms fn t =
        testCase "appendFileUTF8 fail" $ appnd perms fn t ‚â´ assertIsLeft
   in testGroup "withFile"
                [ -- WRITE NEW FILE NO PERMS, CHECK FOR FAILURE
                  testWriteFail Nothing f txt
                , testWrite (Just 0o600) f txt
                , testRead f txt
                -- re-write, to check for lack of auto-truncation
                , testWriteNoTrunc (Just 0o600) f t2
                , testRead f (t2 ‚äï drop (length t2) txt)
                , testAppend (Just 0o600) f txt
                , testRead f (t2 ‚äï drop (length t2) txt ‚äï txt)
                -- DELETE
                , testCase "delete" $ —• (unlink f) ‚â´ assertIsRight
                -- TEST READ FAIL
                , testReadFail f
                -- APPEND NEW FAIL
                , testAppendFail Nothing f txt
                , testAppend (Just 0o000) f txt
                -- TEST READ FAIL
                , testReadFail f
                , testCase "chmod" $ —• (chmod 0400 f) ‚â´ assertIsRight
                -- DELETE
                , testCase "delete" $ —• (unlink f) ‚â´ assertIsRight
                ]

unlink ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí Œ≥ ‚Üí Œº ()
unlink (review _File_ ‚Üí fn) = asIOError $ removeLink (fn ‚´• filepath)

chmod ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, FileAs Œ≥) ‚áí FileMode ‚Üí Œ≥ ‚Üí Œº ()
chmod perms (review _File_ ‚Üí fn) = asIOError $ setFileMode (fn ‚´• filepath) perms

----------------------------------------

{- | Read a file in UTF8 encoding using OS-specific line-ending handling.
     Replace any invalid input bytes with the Unicode replacement character
     U+FFFD.
-}
-- plagiarized from https://www.snoyman.com/blog/2016/12/beware-of-readfile
readFileUTF8Lenient ‚à∑ (AsIOError Œµ, MonadError Œµ Œº, MonadIO Œº, FileAs Œ≥) ‚áí
                      Œ≥ ‚Üí Œº ùïã
readFileUTF8Lenient fn = decodeUtf8With lenientDecode ‚ä≥ readFileBinary fn

----------------------------------------

hClose ‚à∑ ‚àÄ Œµ Œº . (AsIOError Œµ, MonadError Œµ Œº, MonadIO Œº) ‚áí Handle ‚Üí Œº ()
hClose = asIOError ‚àò System.IO.hClose

-- fileAccess ----------------------------------------------

data AccessMode = ACCESS_R | ACCESS_WX | ACCESS_RWX
                | ACCESS_W | ACCESS_RX
                | ACCESS_X | ACCESS_RW

access ‚à∑ ‚àÄ Œµ œÅ Œº . (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, AsFilePath œÅ) ‚áí
         AccessMode ‚Üí œÅ ‚Üí Œº (ùïÑ ùîπ)
access mode ((‚´• filepath) ‚Üí fp) = asIOErrorY $ go mode fp
  where go ‚à∑ AccessMode ‚Üí FilePath ‚Üí IO ùîπ
        go ACCESS_R   p = Files.fileAccess (p ‚´• filepath) True  False False
        go ACCESS_W   p = Files.fileAccess (p ‚´• filepath) False True  False
        go ACCESS_X   p = Files.fileAccess (p ‚´• filepath) False False True
        go ACCESS_RW  p = Files.fileAccess (p ‚´• filepath) True  True  False
        go ACCESS_RX  p = Files.fileAccess (p ‚´• filepath) True  False True
        go ACCESS_WX  p = Files.fileAccess (p ‚´• filepath) False True  True
        go ACCESS_RWX p = Files.fileAccess (p ‚´• filepath) True  True  True

{- | Simple shortcut for file (or directory) is writable by this user; `Nothing`
     is returned if file does not exist. -}
writable ‚à∑ ‚àÄ Œµ œÅ Œº . (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, AsFilePath œÅ) ‚áí
            œÅ ‚Üí Œº (ùïÑ ùîπ)
writable = access ACCESS_W

----------------------------------------

{- | Is `f` an extant writable file? -}
_isWritableFile ‚à∑ (MonadIO Œº, FileAs Œ≥, MonadError Œµ Œº ,AsIOError Œµ) ‚áí
                  Œ≥ ‚Üí ùïÑ FileStatus -> Œº (ùïÑ ùïã)

_isWritableFile (review _File_ ‚Üí f) st =
  let rJust = return ‚àò Just
   in case st of
        Nothing  ‚Üí rJust $ [fmt|%T does not exist|] f
        Just stp ‚Üí if isDirectory stp
                   then rJust $ [fmt|%T is a directory|] f
                   else writable f ‚â´ \ case
                          Nothing    ‚Üí rJust $ [fmt|no such file %T|] f
                          Just True  ‚Üí return Nothing
                          Just False ‚Üí rJust $ [fmt|cannot write to %T|] f

----------------------------------------

{- | Is `f` an extant writable file? -}
isWritableFile ‚à∑ (MonadIO Œº, FileAs Œ≥, MonadError Œµ Œº, AsIOError Œµ) ‚áí
                 Œ≥ -> Œº (ùïÑ ùïã)

isWritableFile (review _File_ ‚Üí f) = stat f ‚â´ _isWritableFile f

----------------------------------------

{- | Is `d` an extant writable directory? -}
isWritableDir ‚à∑ ‚àÄ Œ± Œµ Œº .
                (MonadIO Œº, IsDir Œ±, AsFilePath Œ±, MonadError Œµ Œº, AsIOError Œµ)‚áí
                Œ± -> Œº (ùïÑ ùïã)

isWritableDir d =
  let rJust = return ‚àò Just
   in stat d ‚â´ \ case
        Nothing  ‚Üí rJust $ [fmt|%T does not exist|] d
        Just stp ‚Üí if isDirectory stp
                   then writable d ‚â´ \ case
                          Nothing    ‚Üí rJust $ [fmt|no such directory %T|] d
                          Just True  ‚Üí return Nothing
                          Just False ‚Üí rJust $ [fmt|cannot write to %T|] d
                   else -- remove trailing '/', since the point is that d is
                        -- not a directory
                        rJust $ [fmt|%s is not a directory|]
                                (exterminate (d ‚´• filepath))

----------

isWritableDirTests ‚à∑ TestTree
isWritableDirTests =
  let testE f e = testCase (toString f) $
                    —• (isWritableDir @_ @IOError f) ‚â´ assertRight (Just e @=?)
      testN f   = testCase (toString f) $
                    —• (isWritableDir @_ @IOError f) ‚â´ assertRight (Nothing @=?)
   in testGroup "isWritableDir"
            [ testN [absdir|/tmp/|]
            , testE [absdir|/nonsuch/|]
                    "/nonsuch/ does not exist"
            , testE [absdir|/nonsuch/passwd/|]
                    "/nonsuch/passwd/ does not exist"
            , testE [absdir|/etc/|]
                    "cannot write to /etc/"
            , testE [absdir|/etc/passwd/|]
                    "/etc/passwd is not a directory"
            ]

----------------------------------------

{- | Test that the given path is a writable (by this user) *file*, or does not
     exist but is in a directory that is writable & executable by this user.
     In case of not writable, some error text is returned to say why.
 -}
fileWritable ‚à∑ ‚àÄ Œ≥ Œµ Œº .
               (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
               Œ≥ ‚Üí Œº (ùïÑ ùïã)
fileWritable (review _File_ ‚Üí fn) = do
  stat fn ‚â´ \ case
    Just st ‚Üí _isWritableFile fn (Just st)
    Nothing ‚Üí -- fn does not exist; does it have a writeable dir parent?
              isWritableDir (fn ‚ä£ parent) ‚â´ \ case
                   Nothing ‚Üí return Nothing
                   Just e  ‚Üí return ‚àò Just $ [fmt|%t (%T)|] e fn

----------

fileWritableTests ‚à∑ TestTree
fileWritableTests =
  let testE f e = testCase (toString f) $
                    —• (fileWritable @_ @IOError f) ‚â´ assertRight (Just e @=?)
      testE' f e = testCase (toString f) $
                     —• (fileWritable @_ @IOError f) ‚â´ assertRight (e @=?)

   in testGroup "fileWritable"
            [ testE [absfile|/etc/passwd|]
                    "cannot write to /etc/passwd"
            , testE [absfile|/nonsuch/passwd|]
                    "/nonsuch/ does not exist (/nonsuch/passwd)"
            , testE [absfile|/etc/nonsuch|]
                    "cannot write to /etc/ (/etc/nonsuch)"
            , testE [absfile|/etc/passwd/nonsuch|]
                    "/etc/passwd is not a directory (/etc/passwd/nonsuch)"
            , testE [absfile|/etc/pam.d|]
                    "/etc/pam.d is a directory"

            , testE' [absfile|/dev/null|] Nothing
            ]

----------------------------------------

{- | Work over a file, accumulating results, line-by-line. -}
fileFoldLinesUTF8 ‚à∑ (MonadIO Œº, FileAs Œ≥, AsIOError Œµ, MonadError Œµ Œº) ‚áí
                     Œ± ‚Üí (Œ± ‚Üí ùïã ‚Üí IO Œ±) ‚Üí Œ≥ ‚Üí Œº Œ±
fileFoldLinesUTF8 a io fn = withReadFileUTF8 fn $ fileFoldLinesH a io

fileFoldLinesH ‚à∑ (MonadIO Œº) ‚áí Œ± ‚Üí (Œ± ‚Üí ùïã ‚Üí Œº Œ±) ‚Üí Handle ‚Üí Œº Œ±
fileFoldLinesH a io h = do
  eof ‚Üê liftIO $ hIsEOF h
  case eof of
    True  ‚Üí return a
    False ‚Üí do l ‚Üê liftIO $ TextIO.hGetLine h
               a' ‚Üê io a l
               fileFoldLinesH a' io h

----------------------------------------

{- | An open RW handle to /dev/null. -}
devnull ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº) ‚áí Œº Handle
devnull = openFileReadWriteNoTruncBinary Nothing [absfile|/dev/null|]

----------------------------------------

tests ‚à∑ TestTree
tests = testGroup "MonadIO.File" [ fexistsTests, fexists'Tests, statTests
                                 , isWritableDirTests, fileWritableTests
                                 , withFileTests ]

--------------------

_test ‚à∑ IO ExitCode
_test = runTestTree tests

--------------------

_tests ‚à∑ String ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ String ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------

