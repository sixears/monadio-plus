{-# LANGUAGE FlexibleContexts  #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE RankNTypes        #-}
{-# LANGUAGE TypeApplications  #-}
{-# LANGUAGE UnicodeSyntax     #-}
{-# LANGUAGE ViewPatterns      #-}

module MonadIO.Temp
  ( OutputData(..), mkTempDir
  , tempfile, tempfile', tempfile''
  , testsWithTempfile, testsWithTempfiles, testsWithTempfiles'
  , withTempDir'', withTempDirCD, withTempDirCD'
  , withTempfile, withTempfile', withTempfile'', withTempfile'''

  , tests
  )
where

import Base1T

-- base --------------------------------

import qualified  System.IO

import Control.Monad          ( (>=>) )
import Data.Function          ( flip )
import Data.Functor.Identity  ( Identity( Identity ), runIdentity )
import Data.List              ( dropWhileEnd )
import Data.Maybe             ( fromJust )
import Data.Tuple             ( uncurry )
import System.Environment     ( getProgName )
import System.IO              ( FilePath, Handle
                              , SeekMode( AbsoluteSeek )
                              , char8, hSeek, hSetEncoding, hSetNewlineMode
                              , nativeNewlineMode, noNewlineTranslation, utf8
                              )

-- bytestring --------------------------

import qualified Data.ByteString  as  BS

import Data.ByteString  ( ByteString )

-- exceptions --------------------------

import Control.Monad.Catch  ( MonadMask, bracket )

-- fpath -------------------------------

import FPath.AbsDir            ( AbsDir )
import FPath.AbsFile           ( AbsFile )
import FPath.AsFilePath        ( filepath )
import FPath.Dir               ( DirAs( _Dir_ ) )
import FPath.Error.FPathError  ( AsFPathError, FPathIOError )
import FPath.File              ( FileAs )
import FPath.Parseable         ( Parseable( parse ) )
import FPath.PathComponent     ( PathComponent )

-- lens --------------------------------

import Control.Lens.At         ( ix )
import Control.Lens.Each       ( Each, each )
import Control.Lens.Fold       ( mapMOf_ )
import Control.Lens.Traversal  ( mapMOf )
import Control.Lens.Tuple      ( _1, _2, _3 )

-- monaderror-io -----------------------

import MonadError.IO        ( ”ù, asIOErrorT )
import MonadError.IO.Error  ( IOError )

-- mtl ---------------------------------

import Control.Monad.State   ( MonadState, modify, runStateT )
import Control.Monad.Trans   ( lift )

-- natural -----------------------------

import Natural  ( length )

-- tasty-hunit -------------------------

import Test.Tasty.HUnit  ( Assertion )

-- tasty-plus --------------------------

import TastyPlus  ( (‚âü), ioTests, withResourceCleanup )

-- temporary ---------------------------

import System.IO.Temp  ( createTempDirectory, getCanonicalTemporaryDirectory
                       , withTempDirectory )

-- text --------------------------------

import qualified  Data.Text.IO  as  TextIO

import Data.Text  ( unpack )

------------------------------------------------------------
--                     local imports                      --
------------------------------------------------------------

import MonadIO            ( warn )
import MonadIO.Base       ( hClose, unlink )
import MonadIO.Directory  ( inDir )
import MonadIO.OpenFile   ( readFile )

--------------------------------------------------------------------------------

type ‚Ñç  = Handle
type ùîπùïä = ByteString

----------------------------------------

parseAbsDir ‚à∑ (AsFPathError Œµ, MonadError Œµ Œ∑) ‚áí FilePath ‚Üí Œ∑ AbsDir
parseAbsDir = parse ‚àò (‚äï "/") ‚àò dropWhileEnd (‚â° '/')

----------------------------------------

openTempFile ‚à∑ ‚àÄ Œµ Œ¥ Œæ Œº .
               (MonadIO Œº, DirAs Œ¥, ReturnFNFH Œæ,
                AsIOError Œµ, AsFPathError Œµ, MonadError Œµ Œº, HasCallStack) ‚áí
               Œ¥ -- ^ Dir in which tmpfile is to be created
             ‚Üí PathComponent -- ^ Pattern for filename of tmpfile.  See
                             -- `System.IO.openTempFile` for details; a unique
                             -- large random integer is inserted between the
                             -- body of the filename and the extension (if any).
             ‚Üí Œº Œæ -- ^ May be a filename & filehandle pair; or just a handle
                   --   (file will be deleted immediately upon creation) or just
                   --   a filename (handle will be closed).
openTempFile (review $ filepath ‚àò _Dir_ ‚Üí d) (review filepath ‚Üí r) = do
  (fn,fh) ‚Üê asIOError $ System.IO.openTempFile d r
  fn' ‚Üê parse @AbsFile fn
  toFNFH fn' fh

----------------------------------------

{- | Data that may be written to a filehandle, setting encoding and newline
     mode; `Text` is written as utf8 with native line-endings, while
     `ByteString`s are written as bytes with no newline translation.  `String`s
     are written as latin1 with native line-endings.  The `Handle` is left in
     whatever encoding & newline-translation is implied by the input type.
 -}

class OutputData œÑ where
  output ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, HasCallStack) ‚áí ‚Ñç ‚Üí œÑ ‚Üí Œº ()

instance OutputData ùïä where
  output h t = asIOError $ do
    hSetEncoding      h utf8
    hSetNewlineMode   h nativeNewlineMode
    System.IO.hPutStr h t

instance OutputData ùïã where
  output h t = asIOError $ do
    hSetEncoding     h utf8
    hSetNewlineMode  h nativeNewlineMode
    TextIO.hPutStr   h t

instance OutputData ùîπùïä where
  output h bs = asIOError $ do
    hSetEncoding     h char8
    hSetNewlineMode  h noNewlineTranslation
    BS.hPutStr       h bs

instance OutputData () where
  {- | No data output (obviously), no setting of encoding or newline-translation
       mode. -}
  output _ () = return ()

------------------------------------------------------------

{- | A type of things that can be returned by some tempfile functions; if
     the return is an `AbsFile` only; the `Handle` is closed; if the return
     is a `Handle` only, the `AbsFile` is deleted before the return (else it's
     up to the client to arrange cleanup).

     Unless stated otherwise, the `Handle` is opened in `ReadWrite` mode.
-}
class ReturnFNFH œâ where
  toFNFH ‚à∑ (MonadIO Œº, AsIOError Œµ, MonadError Œµ Œº, HasCallStack) ‚áí
           AbsFile ‚Üí ‚Ñç ‚Üí Œº œâ

instance ReturnFNFH ‚Ñç where
  toFNFH fn fh = unlink fn ‚™º return fh

instance ReturnFNFH AbsFile where
  toFNFH fn fh = hClose fh ‚™º return fn

instance ReturnFNFH (AbsFile, ‚Ñç) where
  toFNFH fn fh = return (fn,fh)

------------------------------------------------------------

{- | Create a temporary file, return it as name and/or filehandle.  Any content
     provided is pre-written to the file (and access position for the filehandle
     returned, if any, reset to the beginning of the file).
  -}

tempfile'' ‚à∑ ‚àÄ Œµ Œ¥ œÑ Œæ Œº .
             (MonadIO Œº, DirAs Œ¥, OutputData œÑ, ReturnFNFH Œæ,
              AsIOError Œµ, AsFPathError Œµ, MonadError Œµ Œº, HasCallStack) ‚áí
             Œ¥             -- ^ Directory in which the file is made.
           ‚Üí PathComponent -- ^ Pattern for the file name.  If this pattern has
                           --   an extension suffix, that is removed before a
                           --   hyphen and a guaranteed-unique integer is added
                           --   to the end of the filename; then the extension
                           --   (if any) is re-added.
                           --   See `System.IO.openTempFile`.
           ‚Üí œÑ             -- ^ Content to write to the file before returning.
           ‚Üí Œº Œæ           -- ^ If the return type is a Handle (only), the file
                           --   is deleted before returning. If a filename
                           --   (only) is the return type, the handle is closed
                           --   before returning.  Note that if the filename
                           --   is part of the return type, then it is the
                           --   client's responsibility to delete that when
                           --   done.  See also `withTempfile`.

tempfile'' d r t = do
  (fn,h) ‚Üê openTempFile d r
  output h t
  asIOError $ hSeek h AbsoluteSeek 0
  toFNFH fn h

--------------------

{- | Like `tempfile''`, but using the system temp directory. -}
tempfile' ‚à∑ ‚àÄ Œµ œÑ Œæ Œº .
            (MonadIO Œº, OutputData œÑ, ReturnFNFH Œæ,
             AsIOError Œµ, AsFPathError Œµ, MonadError Œµ Œº, HasCallStack) ‚áí
            PathComponent ‚Üí œÑ ‚Üí Œº Œæ
tempfile' r t = tempdir ‚â´ \ d ‚Üí tempfile'' d r t

--------------------

{- | Like `tempfile'`, but using the progname as the file pattern. -}
tempfile ‚à∑ ‚àÄ Œµ œÑ Œæ Œº .
           (MonadIO Œº, OutputData œÑ, ReturnFNFH Œæ,
            AsIOError Œµ, AsFPathError Œµ, MonadError Œµ Œº, HasCallStack) ‚áí
           œÑ ‚Üí Œº Œæ
tempfile t = progNamePrefix ‚â´ \ p ‚Üí tempfile' p t

----------------------------------------

{- | Take a possibly error-throwing action, and if that error occurs, push it
     onto a stack; returning () whatever happens. -}
stackE ‚à∑ ‚àÄ Œµ Œ∑ . MonadState [Œµ] Œ∑ ‚áí ExceptT Œµ Œ∑ () ‚Üí Œ∑ ()
stackE go = join $ either (modify ‚àò (:)) return ‚ä≥ —• go

{- | Create a temporary file, and perform some IO with that.

     The handle to the file is closed, and the file deleted after use.  Any
     IOErrors raised by these actions are returned in the list that is the
     second part of the return

     either of these actions raise an IOError, then that is written to the
     `MonadState`.
 -}
withTempfile''' ‚à∑ ‚àÄ Œµ Œæ Œ¥ œÑ œâ Œº .
                 (MonadIO Œº, MonadMask Œº, DirAs Œ¥, OutputData œÑ,
                  MonadError Œµ Œº, AsIOError Œµ, AsFPathError Œµ, HasCallStack,
                  AsIOError Œæ) ‚áí
                 Œ¥                   -- ^ Write the tempfile to this dir.
               ‚Üí PathComponent       -- ^ Pattern to use for the temfile
                                     --   name.  See `tempfile` for details.
               ‚Üí œÑ                   -- ^ Any data to write to the temp file
                                     --   before handing it to the `IO` action.
               ‚Üí (AbsFile ‚Üí ‚Ñç ‚Üí Œº œâ) -- ^ An `IO` action to perform, with the
                                     --   tempfile.
               ‚Üí Œº (œâ, [Œæ])          -- ^ The result of the io action, along
                                     --   with any `IOError`s raised during
                                     --   cleanup.

withTempfile''' d p t io = flip runStateT [] $
  bracket
    (tempfile'' d p t)
    (\ (fn,fh) ‚Üí mapM_ stackE [hClose fh, unlink fn])
    (lift ‚àò uncurry io)

--------------------

{- | Like `withTempfile'''`, but writes any errors seen during cleanup to
     stderr. -}
withTempfile'' ‚à∑ ‚àÄ Œµ Œ¥ œÑ œâ Œº .
                 (MonadIO Œº, MonadMask Œº, DirAs Œ¥, OutputData œÑ,
                  MonadError Œµ Œº, AsIOError Œµ, AsFPathError Œµ, HasCallStack) ‚áí
                 Œ¥ ‚Üí PathComponent ‚Üí œÑ ‚Üí (AbsFile ‚Üí Handle ‚Üí Œº œâ) ‚Üí Œº œâ

withTempfile'' d p t io = do
  (w, es) ‚Üê withTempfile''' @_ @IOError d p t io
  forM_ es warn
  return w

--------------------

{- | Like `withTempfile''`, but uses the system temp directory. -}
withTempfile' ‚à∑ ‚àÄ Œµ œÑ œâ Œº .
                (MonadIO Œº, MonadMask Œº, OutputData œÑ,
                 MonadError Œµ Œº, AsIOError Œµ, AsFPathError Œµ, HasCallStack) ‚áí
                PathComponent ‚Üí œÑ ‚Üí (AbsFile ‚Üí Handle ‚Üí Œº œâ) ‚Üí Œº œâ
withTempfile' r t io = tempdir ‚â´ \ d ‚Üí withTempfile'' d r t io

--------------------

{- | Like `withTempfile'`, but uses the program name as the file pattern. -}
withTempfile ‚à∑ ‚àÄ Œµ œÑ œâ Œº .
               (MonadIO Œº, MonadMask Œº, OutputData œÑ,
                MonadError Œµ Œº, AsIOError Œµ, AsFPathError Œµ, HasCallStack) ‚áí
               œÑ ‚Üí (AbsFile ‚Üí Handle ‚Üí Œº œâ) ‚Üí Œº œâ
withTempfile t io = progNamePrefix ‚â´ \ p ‚Üí withTempfile' p t io

----------------------------------------

{- | Get the system temporary directory (TMPDIR, etc.) -}
tempdir ‚à∑ ‚àÄ Œµ Œº .
          (MonadIO Œº, AsFPathError Œµ, AsIOError Œµ, MonadError Œµ Œº,
           HasCallStack) ‚áí
          Œº AbsDir
tempdir = asIOError getCanonicalTemporaryDirectory ‚â´ parseAbsDir

----------------------------------------

{- | Create a temporary directory as a subdir of a given dir; return its name.
     It is the responsibility of the caller to arrange appropriate cleanup. -}
mkTempDir'' ‚à∑ ‚àÄ Œµ Œ¥ Œº .
              (MonadIO Œº, AsFPathError Œµ, AsIOError Œµ, MonadError Œµ Œº,
               HasCallStack, DirAs Œ¥) ‚áí
              Œ¥ ‚Üí PathComponent ‚Üí Œº AbsDir
mkTempDir'' (review $ filepath ‚àò _Dir_ ‚Üí t) (review filepath ‚Üí r) = do
  d ‚Üê liftIO $ createTempDirectory t r
  parseAbsDir d

--------------------

{- | `mkTempDir''`, but create a dir in the system temp dir. -}
mkTempDir' ‚à∑ ‚àÄ Œµ Œº .
             (MonadIO Œº, AsFPathError Œµ, AsIOError Œµ, MonadError Œµ Œº,
              HasCallStack) ‚áí
             PathComponent ‚Üí Œº AbsDir
mkTempDir' r = tempdir ‚â´ \ d ‚Üí mkTempDir'' d r

--------------------

{- | `mkTempDir'`, with the prefix being the program name plus `"-"`. -}
mkTempDir ‚à∑ ‚àÄ Œµ Œº .
            (MonadIO Œº, AsFPathError Œµ, AsIOError Œµ, MonadError Œµ Œº,
             HasCallStack) ‚áí
            Œº AbsDir
mkTempDir = progNamePrefix ‚â´ mkTempDir'

----------------------------------------

_parseD ‚à∑ (Parseable œá, AsFPathError Œµ, MonadError Œµ Œ∑) ‚áí FilePath ‚Üí Œ∑ œá
_parseD = parse ‚àò (‚äï "/") ‚àò dropWhileEnd (‚â° '/')

{- | Perform some IO with a given temporary directory, created within some given
     dir; the temporary dir is removed once IO is complete.  The directory
     created is passed into the IO as an `AbsDir`.  The directory name is
     prefixed by some relative name.
 -}
-- note that withTempDirectory will give us a relative dir if passed a relative
-- dir (that exists and is usable)
withTempDir'' ‚à∑ ‚àÄ Œµ œâ Œ¥ Œº .
                (MonadIO Œº, MonadMask Œº, AsFPathError Œµ, AsIOError Œµ,
                 MonadError Œµ Œº, HasCallStack, DirAs Œ¥, Parseable Œ¥) ‚áí
                Œ¥ ‚Üí PathComponent ‚Üí (Œ¥ ‚Üí ExceptT Œµ IO œâ) ‚Üí Œº œâ
withTempDir'' d (review filepath ‚Üí r) io =
  asIOErrorT $ withTempDirectory (d ‚´• filepath ‚àò _Dir_) r (_parseD >=> io)

----------

{- | Perform some IO with a temporary directory (created in the system temp
     directory, see `tempdir`), which is removed once IO is complete.  The
     directory created is passed into the IO as an `AbsDir`.  The directory name
     is prefixed by some relative name.
 -}
withTempDir' ‚à∑ ‚àÄ Œµ œâ Œº .
               (MonadIO Œº, MonadMask Œº, AsFPathError Œµ, AsIOError Œµ,
                MonadError Œµ Œº, HasCallStack) ‚áí
               PathComponent ‚Üí (AbsDir ‚Üí ExceptT Œµ IO œâ) ‚Üí Œº œâ
withTempDir' r io = tempdir ‚â´ \ d ‚Üí withTempDir'' d r io

{- | A prefix (suitable for, e.g., temp files or dirs) in the form of a
     `RelFile` (which is the programme name, plus a '-' character. -}
progNamePrefix ‚à∑ ‚àÄ Œµ Œº .
                 (MonadIO Œº, AsFPathError Œµ, AsIOError Œµ, MonadError Œµ Œº,
                  HasCallStack) ‚áí
                 Œº PathComponent
progNamePrefix = asIOError getProgName ‚â´ parse ‚àò (‚äï "-")

{- | Like `withTempDir'`, with the prefix being the program name plus `"-"`. -}
withTempDir ‚à∑ ‚àÄ Œµ œâ Œº .
              (MonadIO Œº, MonadMask Œº, AsFPathError Œµ, AsIOError Œµ,
               MonadError Œµ Œº, HasCallStack) ‚áí
              (AbsDir ‚Üí ExceptT Œµ IO œâ) ‚Üí Œº œâ
withTempDir io = progNamePrefix ‚â´ \ p ‚Üí withTempDir' p io

{- | Like `withTempDir`, but temporarily changes dir into the temporary
     directory, rather than passing the dir name to the IO. -}
withTempDirCD ‚à∑ ‚àÄ Œµ œâ Œº .
                (MonadIO Œº, MonadMask Œº, AsFPathError Œµ, AsIOError Œµ,
                 MonadError Œµ Œº, HasCallStack) ‚áí
                ExceptT Œµ IO œâ ‚Üí Œº œâ
withTempDirCD io = withTempDir (flip inDir io)

{- | Like `withTempDir`, but temporarily changes dir into the temporary
     directory, as well as passing the dir name to the IO. -}
withTempDirCD' ‚à∑ ‚àÄ Œµ œâ Œº .
                 (MonadIO Œº, MonadMask Œº, AsFPathError Œµ, AsIOError Œµ,
                  MonadError Œµ Œº, HasCallStack) ‚áí
                 (AbsDir ‚Üí ExceptT Œµ IO œâ) ‚Üí Œº œâ
withTempDirCD' io = withTempDir (\ d ‚Üí inDir d $ io d)

----------------------------------------

{-| perform tests using a testfile, which is created as a tempfile with given
    text contents -}
testsWithTempfile ‚à∑ ùïã ‚Üí [(TestName, AbsFile ‚Üí Assertion)] ‚Üí TestTree
testsWithTempfile txt tsts =
  testsWithTempfiles "testsWithTempfile"
                     (Identity txt) (second (‚àò runIdentity) ‚ä≥ tsts)

----------

testsWithTempfileTests ‚à∑ TestTree
testsWithTempfileTests =
  let foo = "foo" ‚à∑ ùïã

      doTest txt exp =
        let readfile ‚à∑ AbsFile ‚Üí IO ùïã = ”ù ‚àò readFile @IOError
         in testsWithTempfile txt [(unpack exp,(\ x‚Üí readfile x ‚â´ (‚âü exp)))]
  in testGroup "testsWithTempfile"
               [ doTest foo foo
               ]

----------------------------------------

-- This exists purely for development; it should be a strict specialization
-- of testsWithTempfiles', using [] & AbsFile rather than Each & FileAs; to
-- enable us to work against a concrete, comprehensible type signature (and use
-- the hints that the compiler may give us).
_testsWithTempfiles ‚à∑ ‚àÄ œÑ Œ¥ . (OutputData œÑ) ‚áí
                      TestName
                    ‚Üí [œÑ]
                    -- other IO, whose result to pass to the tests
                    ‚Üí ([(AbsFile,‚Ñç)] ‚Üí IO Œ¥)
                    -- setup for other IO
                    ‚Üí (Œ¥ ‚Üí IO())
                    -- release for other IO
                    ‚Üí (Œ¥ ‚Üí IO())
                    ‚Üí [(TestName, [AbsFile] ‚Üí Œ¥ ‚Üí Assertion)]
                    ‚Üí TestTree

_testsWithTempfiles name
                    txts
                    acquire
                    setup
                    release tsts =
  let f_fsts          ‚à∑ ([AbsFile]‚Üí Œ¥‚Üí Assertion)‚Üí ([(AbsFile,‚Ñç)],Œ¥) ‚Üí Assertion
      f_fsts f (xs,z) = f (xs & each ‚äß fst) z
      hclose          = ”ù ‚àò hClose @IOError
      rm              = ”ù ‚àò unlink @IOError
      tempFile        = tempfile @FPathIOError
      tsts'           ‚à∑ IO ([(AbsFile,‚Ñç)],Œ¥) ‚Üí TestTree
      tsts' io_fs_x   = ioTests name (fmap (second f_fsts) tsts) io_fs_x
      acquire'        = do
        fs ‚Üê ”ù $ mapMOf each tempFile txts
        x  ‚Üê acquire fs
        return (fs,x)
      setup' (fs,x)   = do
        mapMOf_ each (hclose ‚àò snd) fs
        setup x
      release' (fs,x) = do
        mapMOf_ each (rm ‚àò fst) fs
        release x
  in withResourceCleanup acquire' setup' release' tsts'


----------------------------------------

{- | Perform tests using a number of testfiles, which are created as tempfiles
     with the given contents.  Also, take some arbitrary IO, with acquire, setup
     and release functions (see `ioTests`); pass the result of that IO also
     to the tests.

     Note that when the acquire is run for the arbitrary IO; the tempfiles
     have been created and written, but their filehandles not closed; the
     filehandles are closed before the setup is called for the arbitrary IO.

     This type signature roughly equates to

     > (OutputData œÑ, FileAs Œ≤) ‚áí
     > TestName ‚Üí œÜ œÑ ‚Üí IO Œ¥ ‚Üí (Œ¥ ‚Üí IO()) ‚Üí (Œ¥ ‚Üí IO())
     >          ‚Üí [(TestName, (œÜ Œ≤,Œ¥) ‚Üí Assertion)] ‚Üí TestTree

     Where œÜ is a traversable collection; e.g., @[œÑ]@ or @(œÑ,œÑ,œÑ)@.
     Note that to use a single tempfile, you need an instance of @Each@ that has
     a single data member - e.g., @Identity@.
-}
-- Each s t a b; s is a container for a, t is a container for b
-- s -> a, t -> b, s b -> t, t a -> s
-- a is the input type, b is the output type, s, t are the input/output
-- containers respectively.

testsWithTempfiles' ‚à∑ ‚àÄ œÑ Œ≥ Œ¥
                        œÉ -- container for œÑ; same container as used for
                          -- (Œ≥,‚Ñç) when passed around, and passed to the tests
                        Œæ -- container for (Œ≥, ‚Ñç); same container as used
                          -- for input file contents, and passed to
                          -- the tests
                        Œ≤ -- the container of the type passed to each test;
                          -- roughly ([Œ≥],Œ¥) or ((Œ≥,Œ≥,Œ≥),Œ¥), etc.
                        .
                      (OutputData œÑ, -- type of tempfile contents, e.g., ùïã
                       FileAs Œ≥, -- fileish thing to create, e.g., AbsFile
                       Each œÉ Œæ œÑ (Œ≥,‚Ñç), ReturnFNFH (Œ≥,‚Ñç),
                       Each Œæ Œ≤ (Œ≥,‚Ñç) Œ≥, Each Œæ Œæ (Œ≥,‚Ñç) (Œ≥,‚Ñç)
                      ) ‚áí
                      TestName
                    ‚Üí œÉ          {- ^ collection of texts, or similar; contents
                                      of each temp file -}
                    ‚Üí (Œæ ‚Üí IO Œ¥) {- ^ other IO, whose result to pass to the
                                      tests -}
                    ‚Üí (Œ¥ ‚Üí IO()) {- ^ setup for other IO -}
                    ‚Üí (Œ¥ ‚Üí IO()) {- ^ release for other IO -}
--                    ‚Üí [(TestName, (Œ≤,Œ¥) ‚Üí Assertion)]
                    ‚Üí [(TestName, Œ≤ ‚Üí Œ¥ ‚Üí Assertion)]
                    ‚Üí TestTree

testsWithTempfiles' name txts acquire setup release tsts =
  let -- take a function from ([file],extra_io_out) to assertion and produce a
      -- function from ([(file,handle)],extra_io_out) to assertion

      -- roughly; f_fst ‚à∑ ([x] ‚Üí y ‚Üí z) ‚Üí ([(x,_)],y) ‚Üí z
      f_fsts f (xs,z) = f (xs & each ‚äß fst) z
      hclose        = ”ù ‚àò hClose @IOError
      rm            = ”ù ‚àò unlink @IOError
      tempFile      = tempfile @FPathIOError
      acquire'      = do
        fs ‚Üê ”ù $ mapMOf each tempFile txts
        x  ‚Üê acquire fs
        return (fs,x)
      setup' (fs,x)   = do
        mapMOf_ each (hclose ‚àò snd) fs
        setup x
      release' (fs,x) = do
        mapMOf_ each (rm ‚àò fst) fs
        release x
      -- map f_fsts to the test fn part of `[(TestName, Œ≤ ‚Üí Œ¥ ‚Üí Assertion)]`
      -- something like
      -- tsts' ‚à∑ IO (Œ≤,Œ¥) ‚Üí TestTree
      tsts' io_fs_x = ioTests name (fmap (second f_fsts) tsts) io_fs_x
  in withResourceCleanup acquire' setup' release' tsts'

--------------------

class Len Œ± where
  len ‚à∑ Œ± ‚Üí ‚Ñï
instance Len (Identity Œ≤) where
  len _ = 1
instance Len (Œ≤,Œ≤') where
  len _ = 2
instance Len (Œ≤,Œ≤',Œ≤'') where
  len _ = 3
instance Len [Œ≤] where
  len = length

testsWithTempfiles'Tests ‚à∑ TestTree
testsWithTempfiles'Tests =
  let foo = "foo" ‚à∑ ùïã
      bar = "bar" ‚à∑ ùïã
      baz = "baz" ‚à∑ ùïã

      doTest name txts exps n =
        let readfile ‚à∑ AbsFile ‚Üí IO ùïã = ”ù ‚àò readFile @IOError
         in testsWithTempfiles' name txts (\ fs ‚Üí return (len fs))
                                (const $ return ()) (const $ return ())
                                [ (unpack t,(\ x y ‚Üí do
                                                t' ‚Üê readfile (x‚ä£f)
                                                t ‚âü t'
                                                n @=? y
                                            ))
                                | (t,f) ‚Üê exps]
      doTest' name txts exps n =
        let readfile ‚à∑ ùïÑ AbsFile ‚Üí IO ùïã = ”ù ‚àò readFile @IOError ‚àò fromJust
         in testsWithTempfiles' name txts (\ fs ‚Üí return (len fs))
                                (const $ return ()) (const $ return ())
                                [ (unpack t,(\ x y ‚Üí do
                                                t' ‚Üê readfile (x‚©ºf)
                                                t' ‚âü t
                                                n @=? y
                                            ))
                                | (t,f) ‚Üê exps]
  in testGroup "testsWithTempfiles'"
               [ doTest "foo" (Identity foo) [(foo,_1)] 1
               , doTest "foo,bar" (foo,bar) [(foo,_1),(bar,_2)] 2
               , doTest "foo,bar,baz" (foo,bar,baz)
                                      [(foo,_1),(bar,_2),(baz,_3)] 3
               , doTest' "list" [foo,bar,baz]
                                [(foo,ix 0),(bar,ix 1),(baz,ix 2)] 3
               ]

----------------------------------------

{- | Perform tests using a number of testfiles, which are created as tempfiles
     with the given contents.

     This type signature roughly equates to

     > (OutputData œÑ, FileAs Œ≤) ‚áí œÜ œÑ ‚Üí [(TestName, œÜ Œ≤ ‚Üí Assertion)] ‚Üí TestTree

     Where œÜ is a traversable collection; e.g., @[œÑ]@ or @(œÑ,œÑ,œÑ)@.
     Note that to use a single tempfile, you need an instance of @Each@ that has
     a single data member - e.g., @Identity@.

     This is `testsWithTempfiles'`; but with the arbitrary IO elided.
-}

testsWithTempfiles ‚à∑ ‚àÄ œÑ Œ≤ œÉ Œæ Œ≥ .
                     (OutputData œÑ, FileAs Œ≥, ReturnFNFH (Œ≥,‚Ñç),
                      Each œÉ Œæ œÑ (Œ≥, ‚Ñç),
                      Each Œæ Œ≤ (Œ≥,‚Ñç) Œ≥, Each Œæ Œæ (Œ≥, ‚Ñç) (Œ≥,‚Ñç)) ‚áí
                     TestName ‚Üí œÉ ‚Üí [(TestName, Œ≤ ‚Üí Assertion)] ‚Üí TestTree


testsWithTempfiles nm fs ts =
  let nowt = const $ return ()
   in testsWithTempfiles' nm fs nowt nowt nowt
                          (fmap (second (\ f ‚Üí \ b () ‚Üí f b)) ts)

----------

testsWithTempfilesTests ‚à∑ TestTree
testsWithTempfilesTests =
  let foo = "foo" ‚à∑ ùïã
      bar = "bar" ‚à∑ ùïã
      baz = "baz" ‚à∑ ùïã

      doTest name txts exps =
        let readfile ‚à∑ AbsFile ‚Üí IO ùïã = ”ù ‚àò readFile @IOError
         in testsWithTempfiles name txts
                               [ (unpack t,(\ x‚Üí readfile (x‚ä£f) ‚â´ (‚âü t)))
                               | (t,f) ‚Üê exps]
      doTest' name txts exps =
        let readfile ‚à∑ ùïÑ AbsFile ‚Üí IO ùïã = ”ù ‚àò readFile @IOError ‚àò fromJust
         in testsWithTempfiles name txts
                               [ (unpack t,(\ x‚Üí(readfile (x‚©ºf)) ‚â´ (‚âü t)))
                               | (t,f) ‚Üê exps]
  in testGroup "testsWithTempfiles"
               [ doTest "foo" (Identity foo) [(foo,_1)]
               , doTest "foo,bar" (foo,bar) [(foo,_1),(bar,_2)]
               , doTest "foo,bar,baz" (foo,bar,baz) [(foo,_1),(bar,_2),(baz,_3)]
               , doTest' "list" [foo,bar,baz] [(foo,ix 0),(bar,ix 1),(baz,ix 2)]
               ]

-- tests -----------------------------------------------------------------------

tests ‚à∑ TestTree
tests = testGroup "Temp" [ testsWithTempfileTests, testsWithTempfilesTests
                         , testsWithTempfiles'Tests ]

----------------------------------------

_test ‚à∑ IO ExitCode
_test = runTestTree tests

--------------------

_tests ‚à∑ String ‚Üí IO ExitCode
_tests = runTestsP tests

_testr ‚à∑ String ‚Üí ‚Ñï ‚Üí IO ExitCode
_testr = runTestsReplay tests

-- that's all, folks! ----------------------------------------------------------
